<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Snake Game</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }

    body {
      background: #1a1a2e;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      color: #eee;
      flex-direction: column;
      gap: 16px;
      user-select: none;
    }

    h1 {
      font-size: 2rem;
      letter-spacing: 4px;
      color: #00d2ff;
      text-transform: uppercase;
    }

    #scoreboard {
      font-size: 1.2rem;
      display: flex;
      gap: 32px;
    }

    #scoreboard span {
      color: #00d2ff;
      font-weight: bold;
    }

    canvas {
      border: 2px solid #00d2ff;
      border-radius: 4px;
      background: #16213e;
    }

    #message {
      font-size: 1.1rem;
      height: 24px;
      color: #aaa;
    }

    /* Mobile controls */
    #controls {
      display: none;
      grid-template-areas:
        ".  up   ."
        "left down right";
      grid-template-columns: 60px 60px 60px;
      grid-template-rows: 60px 60px;
      gap: 6px;
      margin-top: 8px;
    }

    #controls button {
      width: 60px;
      height: 60px;
      font-size: 1.5rem;
      border: 2px solid #00d2ff;
      border-radius: 8px;
      background: #16213e;
      color: #00d2ff;
      cursor: pointer;
      touch-action: manipulation;
    }

    #controls button:active {
      background: #00d2ff;
      color: #1a1a2e;
    }

    .btn-up    { grid-area: up; }
    .btn-down  { grid-area: down; }
    .btn-left  { grid-area: left; }
    .btn-right { grid-area: right; }

    @media (pointer: coarse) {
      #controls { display: grid; }
    }
  </style>
</head>
<body>
  <h1>Snake</h1>
  <div id="scoreboard">
    Score: <span id="score">0</span>
    Best: <span id="best">0</span>
  </div>
  <canvas id="game" width="400" height="400"></canvas>
  <div id="message">Press any arrow key to start</div>

  <div id="controls">
    <button class="btn-up" onclick="setDir(0,-1)">&#9650;</button>
    <button class="btn-left" onclick="setDir(-1,0)">&#9664;</button>
    <button class="btn-down" onclick="setDir(0,1)">&#9660;</button>
    <button class="btn-right" onclick="setDir(1,0)">&#9654;</button>
  </div>

  <script>
    // ---- Settings (tweak these!) ----
    const GRID_SIZE  = 20;   // number of cells per row/column
    const TILE       = 20;   // pixel size of each cell (canvas = GRID_SIZE * TILE)
    const SPEED      = 120;  // milliseconds between moves (lower = faster)

    // ---- Game state ----
    const canvas  = document.getElementById("game");
    const ctx     = canvas.getContext("2d");
    const scoreEl = document.getElementById("score");
    const bestEl  = document.getElementById("best");
    const msgEl   = document.getElementById("message");

    let snake, direction, nextDirection, food, score, bestScore, running, gameOver;

    bestScore = 0;

    function init() {
      snake = [{ x: 10, y: 10 }];
      direction     = { x: 0, y: 0 };
      nextDirection = { x: 0, y: 0 };
      score    = 0;
      running  = false;
      gameOver = false;
      scoreEl.textContent = score;
      msgEl.textContent   = "Press any arrow key to start";
      placeFood();
      draw();
    }

    function placeFood() {
      let pos;
      do {
        pos = {
          x: Math.floor(Math.random() * GRID_SIZE),
          y: Math.floor(Math.random() * GRID_SIZE)
        };
      } while (snake.some(s => s.x === pos.x && s.y === pos.y));
      food = pos;
    }

    function draw() {
      // Background
      ctx.fillStyle = "#16213e";
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // Grid lines (subtle)
      ctx.strokeStyle = "rgba(255,255,255,0.03)";
      for (let i = 0; i <= GRID_SIZE; i++) {
        ctx.beginPath();
        ctx.moveTo(i * TILE, 0);
        ctx.lineTo(i * TILE, canvas.height);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(0, i * TILE);
        ctx.lineTo(canvas.width, i * TILE);
        ctx.stroke();
      }

      // Food
      ctx.fillStyle = "#ff6b6b";
      ctx.beginPath();
      ctx.arc(food.x * TILE + TILE / 2, food.y * TILE + TILE / 2, TILE / 2 - 2, 0, Math.PI * 2);
      ctx.fill();

      // Snake
      snake.forEach((segment, i) => {
        const brightness = 1 - (i / snake.length) * 0.5;
        ctx.fillStyle = `rgba(0, 210, 255, ${brightness})`;
        ctx.fillRect(segment.x * TILE + 1, segment.y * TILE + 1, TILE - 2, TILE - 2);
        ctx.strokeStyle = "#1a1a2e";
        ctx.lineWidth = 1;
        ctx.strokeRect(segment.x * TILE + 1, segment.y * TILE + 1, TILE - 2, TILE - 2);
      });

      // Game over overlay
      if (gameOver) {
        ctx.fillStyle = "rgba(0,0,0,0.6)";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = "#ff6b6b";
        ctx.font = "bold 32px sans-serif";
        ctx.textAlign = "center";
        ctx.fillText("GAME OVER", canvas.width / 2, canvas.height / 2 - 10);
        ctx.fillStyle = "#aaa";
        ctx.font = "16px sans-serif";
        ctx.fillText("Press any arrow key to restart", canvas.width / 2, canvas.height / 2 + 24);
      }
    }

    function update() {
      if (!running || gameOver) return;

      direction = { ...nextDirection };

      const head = {
        x: snake[0].x + direction.x,
        y: snake[0].y + direction.y
      };

      // Wall collision
      if (head.x < 0 || head.x >= GRID_SIZE || head.y < 0 || head.y >= GRID_SIZE) {
        endGame();
        return;
      }

      // Self collision
      if (snake.some(s => s.x === head.x && s.y === head.y)) {
        endGame();
        return;
      }

      snake.unshift(head);

      // Eat food
      if (head.x === food.x && head.y === food.y) {
        score++;
        scoreEl.textContent = score;
        if (score > bestScore) {
          bestScore = score;
          bestEl.textContent = bestScore;
        }
        placeFood();
      } else {
        snake.pop();
      }

      draw();
    }

    function endGame() {
      gameOver = true;
      running  = false;
      msgEl.textContent = "Game Over! Press any arrow key to play again";
      draw();
    }

    // Direction helper for mobile buttons
    function setDir(x, y) {
      if (gameOver) { init(); return; }
      if (direction.x === 0 && direction.y === 0) {
        // First move
        nextDirection = { x, y };
        running = true;
        msgEl.textContent = "";
        return;
      }
      // Prevent reversing
      if (x !== 0 && x === -direction.x) return;
      if (y !== 0 && y === -direction.y) return;
      nextDirection = { x, y };
    }

    // Keyboard controls
    document.addEventListener("keydown", (e) => {
      const key = e.key;
      if (!["ArrowUp","ArrowDown","ArrowLeft","ArrowRight"].includes(key)) return;
      e.preventDefault();

      if (gameOver) { init(); }

      const map = {
        ArrowUp:    { x:  0, y: -1 },
        ArrowDown:  { x:  0, y:  1 },
        ArrowLeft:  { x: -1, y:  0 },
        ArrowRight: { x:  1, y:  0 }
      };

      const dir = map[key];

      if (!running) {
        nextDirection = dir;
        direction = dir;
        running = true;
        msgEl.textContent = "";
        return;
      }

      // Prevent reversing into yourself
      if (dir.x !== 0 && dir.x === -direction.x) return;
      if (dir.y !== 0 && dir.y === -direction.y) return;
      nextDirection = dir;
    });

    // Game loop
    setInterval(update, SPEED);

    // Start
    init();
  </script>
</body>
</html>
